"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const detritus_utils_1 = require("detritus-utils");
const constants_1 = require("./constants");
exports.DependencyTypes = Object.freeze({
    UWS: 'uws',
    WS: 'ws',
});
exports.WebsocketDependency = {
    module: null,
    type: '',
};
[
    exports.DependencyTypes.WS,
    exports.DependencyTypes.UWS,
].forEach((dependency) => {
    try {
        exports.WebsocketDependency.module = require(dependency);
        exports.WebsocketDependency.type = dependency;
    }
    catch (e) { }
});
if (exports.WebsocketDependency.module === null) {
    throw new Error(`Missing a WebSocket Dependency, pick one: ${JSON.stringify(Object.values(exports.DependencyTypes))}`);
}
class BaseSocket extends detritus_utils_1.EventEmitter {
    constructor(url) {
        super();
        this.pings = new detritus_utils_1.BaseCollection();
        this.socket = new exports.WebsocketDependency.module(url);
        this.socket.on(constants_1.SocketEventsBase.PONG, this.onPong.bind(this));
        for (let event of Object.values(constants_1.SocketEventsBase)) {
            if (event === constants_1.SocketEventsBase.PONG) {
                continue;
            }
            this.socket.on(event, this.emit.bind(this, event));
        }
    }
    get closed() {
        return this.socket.readyState === this.socket.CLOSED;
    }
    get closing() {
        return this.socket.readyState === this.socket.CLOSING;
    }
    get connected() {
        return this.socket.readyState === this.socket.OPEN;
    }
    get connecting() {
        return this.socket.readyState === this.socket.CONNECTING;
    }
    get using() {
        return exports.WebsocketDependency.type;
    }
    send(data, callback) {
        if (this.connected) {
            this.socket.send(data, {}, callback);
        }
    }
    close(code = constants_1.SocketCloseCodes.NORMAL, reason = '') {
        if (this.connected) {
            this.socket.close(code, reason);
        }
        for (const [nonce, { reject }] of this.pings) {
            reject(new Error('Socket has closed.'));
            this.pings.delete(nonce);
        }
        this.pings.clear();
        this.socket.removeAllListeners();
        this.removeAllListeners();
    }
    onPong(data) {
        try {
            const { nonce } = JSON.parse(String(data));
            const ping = this.pings.get(nonce);
            if (ping) {
                ping.resolve();
                this.pings.delete(nonce);
            }
        }
        catch (e) {
            // malformed ping?
        }
        this.emit(constants_1.SocketEventsBase.PONG, data);
    }
    async ping(timeout = 1000) {
        if (!this.connected) {
            throw new Error('Socket isn\'t connected.');
        }
        const nonce = `${Date.now()}.${Math.random().toString(36)}`;
        return new Promise((resolve, reject) => {
            const expire = new detritus_utils_1.Timers.Timeout();
            if (timeout) {
                expire.start(timeout, () => {
                    this.pings.delete(nonce);
                    reject(new Error(`Pong took longer than ${timeout}ms.`));
                });
            }
            const now = Date.now();
            new Promise((res, rej) => {
                this.pings.set(nonce, {
                    resolve: res,
                    reject: rej,
                });
                this.socket.ping(JSON.stringify({ nonce }));
            }).then(() => {
                expire.stop();
                resolve(Math.round(Date.now() - now));
            });
        });
    }
}
exports.BaseSocket = BaseSocket;
