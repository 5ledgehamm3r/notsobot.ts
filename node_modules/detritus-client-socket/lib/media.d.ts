import { EventEmitter, Timers } from 'detritus-utils';
import { BaseSocket } from './basesocket';
import { Bucket } from './bucket';
import { Socket as GatewaySocket } from './gateway';
import { Socket as MediaUDPSocket } from './mediaudp';
export interface SocketOptions {
    channelId: string;
    forceMode?: string;
    receive?: boolean;
    serverId: string;
    userId: string;
    video?: boolean;
}
export declare class Socket extends EventEmitter {
    readonly state: string;
    _heartbeat: {
        ack: boolean;
        lastAck: null | number;
        lastSent: null | number;
        interval: Timers.Interval;
        intervalTime: null | number;
        nonce: null | number;
    };
    bucket: Bucket;
    channelId: string;
    endpoint: null | string;
    forceMode: null | string;
    gateway: GatewaySocket;
    identified: boolean;
    killed: boolean;
    promises: Set<{
        reject: Function;
        resolve: Function;
    }>;
    protocol: null | string;
    ready: boolean;
    receiveEnabled: boolean;
    reconnects: number;
    serverId: string;
    socket: BaseSocket | null;
    ssrcs: {
        [key: string]: Map<number, string>;
    };
    transport: MediaUDPSocket | null;
    token: null | string;
    userId: string;
    videoEnabled: boolean;
    constructor(gateway: GatewaySocket, options: SocketOptions);
    readonly closed: boolean;
    readonly closing: boolean;
    readonly connected: boolean;
    readonly connecting: boolean;
    readonly guildId: null | string;
    readonly inDm: boolean;
    readonly sessionId: null | string;
    readonly audioSSRC: number;
    readonly videoSSRC: number;
    readonly rtxSSRC: number;
    resolvePromises(error?: any): void;
    setChannelId(value: string): void;
    setEndpoint(value: string): void;
    setProtocol(value: string): void;
    setState(value: string): void;
    setToken(value: string): void;
    ssrcToUserId(ssrc: number, type?: string): null | string;
    userIdToSSRC(userId: string, type?: 'audio' | 'video'): null | number;
    cleanup(code?: number): void;
    connect(endpoint?: string): void;
    decode(data: any): any;
    disconnect(code?: number, reason?: string): void;
    encode(data: any): null | string;
    handle(data: any): void;
    kill(error?: any): void;
    onClose(target: BaseSocket, event: {
        code: number;
        reason: string;
    }): void;
    onError(target: BaseSocket, event: {
        error: any;
    } | any): void;
    onMessage(target: BaseSocket, event: {
        data: any;
        type: string;
    }): void;
    onOpen(target: BaseSocket): void;
    ping(timeout?: number): Promise<any>;
    send(op: number, d: any, callback?: Function, direct?: boolean): void;
    heartbeat(fromInterval?: boolean): void;
    setHeartbeat(data: {
        heartbeat_interval: number;
    }): void;
    identify(): void;
    resume(): void;
    transportConnect(data: {
        ip: string;
        port: number;
        modes: Array<string>;
        ssrc: number;
    }): void;
    sendClientConnect(callback?: Function): void;
    sendSelectProtocol(options: {
        codecs?: Array<any>;
        data: {
            address: string;
            port: number;
            mode: string;
        };
        protocol?: string;
        rtcConnectionId?: string;
    }, callback?: Function): void;
    sendSpeaking(options: {
        delay?: number;
        ssrc?: number;
        soundshare?: boolean;
        voice?: boolean;
    }, callback?: Function): void;
    sendStateUpdate(options?: {
        selfDeaf?: boolean;
        selfMute?: boolean;
        selfVideo?: boolean;
    }, callback?: Function): void;
    on(event: string, listener: Function): this;
    on(event: 'close', listener: (payload: {
        code: number;
        reason: string;
    }) => any): this;
    on(event: 'killed', listener: () => any): this;
    on(event: 'open', listener: (target: BaseSocket) => any): this;
    on(event: 'packet', listener: (packet: MediaGatewayPacket) => any): this;
    on(event: 'ready', listener: () => any): this;
    on(event: 'socket', listener: (socket: BaseSocket) => any): this;
    on(event: 'state', listener: ({ state }: {
        state: string;
    }) => any): this;
    on(event: 'transport', listener: (transport: MediaUDPSocket) => any): this;
    on(event: 'transportReady', listener: (transport: MediaUDPSocket) => any): this;
    on(event: 'warn', listener: (error: Error) => any): this;
}
export interface MediaGatewayPacket {
    op: number;
    d: any;
}
