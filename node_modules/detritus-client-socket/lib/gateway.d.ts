/// <reference types="node" />
import { URL } from 'url';
import { EventEmitter, BaseCollection, Timers } from 'detritus-utils';
import { BaseSocket } from './basesocket';
import { Bucket } from './bucket';
import { Decompressor } from './decompressor';
import { Socket as MediaSocket } from './media';
export interface SocketOptions {
    autoReconnect?: boolean;
    compress?: boolean | string;
    disabledEvents?: Array<string>;
    encoding?: string;
    guildSubscriptions?: boolean;
    identifyProperties?: IdentifyDataProperties;
    largeThreshold?: number;
    presence?: any;
    reconnectDelay?: number;
    reconnectMax?: number;
    shardCount?: number;
    shardId?: number;
}
export declare class Socket extends EventEmitter {
    readonly state: string;
    _heartbeat: {
        ack: boolean;
        lastAck: null | number;
        lastSent: null | number;
        interval: Timers.Interval;
        intervalTime: null | number;
    };
    autoReconnect: boolean;
    bucket: Bucket;
    compress: string;
    disabledEvents: Array<string>;
    discordTrace: Array<any>;
    decompressor: Decompressor | null;
    encoding: string;
    guildSubscriptions: boolean;
    identifyProperties: IdentifyDataProperties;
    killed: boolean;
    largeThreshold: number;
    mediaGateways: BaseCollection<string, MediaSocket>;
    presence: PresenceOptions | null;
    reconnectDelay: number;
    reconnectMax: number;
    reconnects: number;
    resuming: boolean;
    sequence: number;
    sessionId: null | string;
    shardCount: number;
    shardId: number;
    socket: BaseSocket | null;
    token: string;
    url: URL | null;
    userId: null | string;
    constructor(token: string, options?: SocketOptions);
    readonly closed: boolean;
    readonly closing: boolean;
    readonly connected: boolean;
    readonly connecting: boolean;
    setState(value: string): void;
    makePresence(options?: PresenceOptions): PresenceData;
    getIdentifyData(): IdentifyData;
    getResumeData(): ResumeData;
    cleanup(code?: string | number, reason?: string): void;
    connect(url?: null | string | URL): void;
    decode(data: any, uncompressed?: boolean): any;
    disconnect(code?: number, reason?: string): void;
    handle(data: any, uncompressed?: boolean): void;
    handleDispatch(name: string, data: any): void;
    kill(error?: Error): void;
    onClose(target: BaseSocket, event: {
        code: number;
        reason: string;
    }): void;
    onError(target: BaseSocket, event: {
        error: any;
    } | any): void;
    onMessage(target: BaseSocket, event: {
        data: any;
        type: string;
    }): void;
    onOpen(target: BaseSocket): void;
    ping(timeout?: number): Promise<any>;
    send(op: number, d: any, callback?: Function, direct?: boolean): void;
    heartbeat(fromInterval?: boolean): void;
    setHeartbeat(data: {
        _trace: any;
        heartbeat_interval: number;
    }): void;
    identify(): void;
    resume(): void;
    callConnect(channelId: string, callback?: Function): void;
    flushLfgSubscriptions(subscriptions: any, callback?: Function): void;
    guildStreamCreate(guildId: string, channelId: string, callback?: Function): void;
    lobbyConnect(lobbyId: string, lobbySecret: string, callback?: Function): void;
    lobbyDisconnect(lobbyId: string, callback?: Function): void;
    lobbyVoiceStatesUpdate(voiceStates: Array<{
        lobbyId: string;
        selfDeaf: boolean;
        selfMute: boolean;
    }>, callback?: Function): void;
    requestGuildMembers(guildIds: Array<string> | string, options: {
        limit: number;
        presences?: boolean;
        query: string;
        userIds?: Array<string>;
    }, callback?: Function): void;
    setPresence(options: PresenceOptions, callback?: Function): void;
    streamDelete(streamKey: string, callback?: Function): void;
    streamPing(streamKey: string, callback?: Function): void;
    streamSetPaused(streamKey: string, paused: boolean, callback?: Function): void;
    streamWatch(streamKey: string, callback?: Function): void;
    updateGuildSubscriptions(guildId: string, options?: {
        activities?: boolean;
        channels?: {
            [channelId: string]: Array<[number, number]>;
        };
        members?: Array<string>;
        typing?: boolean;
    }, callback?: Function): void;
    voiceServerPing(callback?: Function): void;
    voiceStateUpdate(guildId?: null | string, channelId?: null | string, options?: {
        selfDeaf?: boolean;
        selfMute?: boolean;
        selfVideo?: boolean;
    }, callback?: Function): void;
    voiceConnect(guildId?: null | string, channelId?: null | string, options?: {
        forceMode?: string;
        receive?: boolean;
        selfDeaf?: boolean;
        selfMute?: boolean;
        selfVideo?: boolean;
        timeout?: number;
        video?: boolean;
    }): Promise<MediaSocket | null>;
    on(event: string, listener: Function): this;
    on(event: 'close', listener: (payload: {
        code: number;
        reason: string;
    }) => any): this;
    on(event: 'killed', listener: () => any): this;
    on(event: 'open', listener: (target: BaseSocket) => any): this;
    on(event: 'packet', listener: (packet: GatewayPacket) => any): this;
    on(event: 'ready', listener: () => any): this;
    on(event: 'socket', listener: (socket: BaseSocket) => any): this;
    on(event: 'state', listener: ({ state }: {
        state: string;
    }) => any): this;
    on(event: 'warn', listener: (error: Error) => any): this;
}
export interface GatewayPacket {
    d: any;
    op: number;
    s: number;
    t: string;
}
export interface IdentifyData {
    compress?: boolean;
    guild_subscriptions?: boolean;
    large_threshold?: number;
    presence?: PresenceData;
    properties: IdentifyDataProperties;
    shard?: Array<number>;
    token: string;
}
export interface IdentifyDataProperties {
    $browser?: string;
    $device?: string;
    $os?: string;
    os?: string;
    browser?: string;
    browser_user_agent?: string;
    browser_version?: string;
    client_build_number?: number;
    client_event_source?: string;
    client_version?: string;
    distro?: string;
    os_version?: string;
    os_arch?: string;
    release_channel?: string;
    window_manager?: string;
}
export interface PresenceActivity {
    applicationId?: string;
    assets?: {
        largeImage?: string;
        largeText?: string;
        smallImage?: string;
        smallText?: string;
    };
    createdAt?: number;
    details?: string;
    flags?: number;
    metadata?: {
        [key: string]: any;
    };
    name: string;
    party?: {
        id?: string;
        size?: Array<[number, number]>;
    };
    secrets?: {
        join?: string;
        match?: string;
        spectate?: string;
    };
    sessionId?: string;
    state?: string;
    syncId?: string;
    timestamps?: {
        end?: number;
        start?: number;
    };
    type: number;
    url?: string;
}
export interface PresenceData {
    activities?: Array<PresenceActivity>;
    afk: boolean;
    game?: PresenceActivity;
    since: number;
    status: string;
}
export interface PresenceOptions extends PresenceData {
    activity?: PresenceActivity;
    game?: PresenceActivity;
}
export interface ResumeData {
    seq?: null | number;
    session_id: null | string;
    token: string;
}
