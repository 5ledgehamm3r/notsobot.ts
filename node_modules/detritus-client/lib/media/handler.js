"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const detritus_client_socket_1 = require("detritus-client-socket");
const { MediaCodecs, MediaCodecTypes, MediaOpCodes, MediaSpeakingFlags, } = detritus_client_socket_1.Constants;
/**
 * Voice Connection Handler
 * @category Handler
 */
class MediaHandler {
    constructor(connection) {
        this.connection = connection;
        this.opHandler = new MediaGatewayOpHandler(this);
        this.gateway.on('packet', this.onPacket.bind(this));
        this.gateway.on('warn', this.connection.emit.bind(this.connection, 'warn'));
        this.gateway.once('killed', this.connection.kill.bind(this.connection));
        this.gateway.once('transportReady', this.onTransportReady.bind(this));
    }
    get client() {
        return this.connection.client;
    }
    get gateway() {
        return this.connection.gateway;
    }
    onPacket(packet) {
        const handler = this.opHandler.getHandler(packet.op);
        if (handler) {
            handler.call(this.opHandler, packet.d);
        }
    }
    onTransportReady(transport) {
        this.connection.emit('ready');
        transport.on('log', this.connection.emit.bind(this.connection, 'log'));
        transport.on('packet', this.onTransportPacket.bind(this));
        transport.on('warn', this.connection.emit.bind(this.connection, 'warn'));
    }
    onTransportPacket(packet) {
        this.connection.emit('packet', packet);
        let data = packet.data;
        try {
            switch (packet.format) {
                case MediaCodecTypes.AUDIO:
                    {
                        if (!this.connection.decodeAudio) {
                            return;
                        }
                        if (packet.codec === MediaCodecs.OPUS) {
                            if (!this.connection.opusDecoder) {
                                throw new Error('No Opus decoder provided');
                            }
                            if (packet.userId !== null) {
                                packet.data = this.connection.decode(packet.userId, data);
                            }
                        }
                    }
                    ;
                    break;
            }
            if (packet.format) {
                this.connection.emit(packet.format, packet);
            }
        }
        catch (error) {
            this.connection.emit('warn', error);
        }
    }
}
exports.MediaHandler = MediaHandler;
/**
 * Media Gateway Op Code Handler
 * @category Handlers
 */
class MediaGatewayOpHandler {
    constructor(handler) {
        this.handler = handler;
    }
    get client() {
        return this.handler.client;
    }
    get connection() {
        return this.handler.connection;
    }
    getHandler(op) {
        return this[op];
    }
    [MediaOpCodes.CLIENT_CONNECT](data) {
        const userId = data['user_id'];
        this.connection.emit('connect', {
            audioSSRC: data['audio_ssrc'],
            user: this.client.users.get(userId),
            userId,
            videoSSRC: data['video_ssrc'],
        });
    }
    [MediaOpCodes.CLIENT_DISCONNECT](data) {
        const userId = data['user_id'];
        if (this.connection.opusDecoders.has(userId)) {
            const opusDecoder = this.connection.opusDecoders.get(userId);
            opusDecoder.delete();
            this.connection.opusDecoders.delete(userId);
        }
        this.connection.emit('disconnect', {
            user: this.client.users.get(userId),
            userId,
        });
    }
    [MediaOpCodes.SPEAKING](data) {
        const priority = (data['speaking'] & MediaSpeakingFlags.PRIORITY) === MediaSpeakingFlags.PRIORITY;
        const soundshare = (data['speaking'] & MediaSpeakingFlags.SOUNDSHARE) === MediaSpeakingFlags.SOUNDSHARE;
        const voice = (data['speaking'] & MediaSpeakingFlags.VOICE) === MediaSpeakingFlags.VOICE;
        const userId = data['user_id'];
        this.connection.emit('speaking', {
            isSpeaking: !!data['speaking'],
            priority,
            soundshare,
            voice,
            ssrc: data['ssrc'],
            user: this.client.users.get(userId),
            userId,
        });
    }
}
exports.MediaGatewayOpHandler = MediaGatewayOpHandler;
