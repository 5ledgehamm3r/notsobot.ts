"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const blankPrefixes = Object.freeze(['']);
/**
 * Command Argument
 * @category Command
 */
class Argument {
    constructor(options) {
        this.default = undefined;
        this.prefixes = new Set(['-']);
        this.type = constants_1.CommandArgumentTypes.STRING;
        options = Object.assign({}, options);
        if (options.prefix !== undefined) {
            if (options.prefixes === undefined) {
                options.prefixes = [];
            }
            options.prefixes.push(options.prefix);
        }
        if (options.prefixes !== undefined) {
            options.prefixes.sort((x, y) => +(x.length < y.length));
            this.prefixes.clear();
            for (let prefix of options.prefixes) {
                prefix = prefix.trim();
                if (options.prefixSpace) {
                    prefix += ' ';
                }
                if (prefix) {
                    this.prefixes.add(prefix);
                }
            }
        }
        this.aliases = (options.aliases || []).map((alias) => alias.toLowerCase());
        this.default = options.default;
        this.label = (options.label || options.name).toLowerCase();
        this.name = options.name.toLowerCase();
        switch (options.type) {
            case Boolean:
                {
                    options.type = constants_1.CommandArgumentTypes.BOOL;
                }
                ;
                break;
            case Number:
                {
                    options.type = constants_1.CommandArgumentTypes.NUMBER;
                }
                ;
                break;
            case String:
                {
                    options.type = constants_1.CommandArgumentTypes.STRING;
                }
                ;
                break;
        }
        this.type = (options.type || this.type);
        switch (this.type) {
            case constants_1.CommandArgumentTypes.BOOL:
                {
                    this.default = !!this.default;
                }
                ;
                break;
        }
    }
    get names() {
        const names = [];
        const prefixes = (this.prefixes.size) ? this.prefixes : blankPrefixes;
        for (let prefix of prefixes) {
            names.push((prefix) ? prefix + this.name : this.name);
            for (let alias of this.aliases) {
                names.push((prefix) ? prefix + alias : alias);
            }
        }
        return names;
    }
    check(name) {
        return this.names.some((n) => n === name);
    }
    getInfo(content) {
        const info = { index: -1, name: '' };
        for (let name of this.names) {
            const index = content.indexOf(name);
            if (index !== -1) {
                info.index = index;
                info.name = name;
                break;
            }
        }
        return info;
    }
    getName(content) {
        for (let name of this.names) {
            if (content.length === name.length) {
                if (content === name) {
                    return name;
                }
            }
            else {
                if (content.startsWith(name + ' ')) {
                    return name;
                }
            }
        }
        return null;
    }
    async parse(value, context) {
        let parsedValue = value || this.default;
        if (typeof (this.type) === 'function') {
            parsedValue = await Promise.resolve(this.type(value, context));
        }
        else {
            switch (this.type) {
                case constants_1.CommandArgumentTypes.BOOL:
                    {
                        parsedValue = !this.default;
                    }
                    ;
                    break;
                case constants_1.CommandArgumentTypes.FLOAT:
                    {
                        parsedValue = parseFloat(value);
                    }
                    ;
                    break;
                case constants_1.CommandArgumentTypes.NUMBER:
                    {
                        parsedValue = parseInt(value);
                    }
                    ;
                    break;
            }
        }
        return parsedValue;
    }
}
exports.Argument = Argument;
